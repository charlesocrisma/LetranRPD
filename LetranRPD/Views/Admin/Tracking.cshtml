@{
	Layout = "~/Views/Shared/_AdminNav.cshtml";
	var currentUser = Context.Session.GetObject<Account>("account");
}
							@using LetranRPD.Models
							@model List<ServiceInformation>
@Html.AntiForgeryToken()


@{
	Func<int, string> GetStatusClass = (status) =>
	{
		switch (status)
		{
			case 0: return "pending";   // Not yet started
			case 1: return "active";    // In progress
			case 2: return "completed"; // Finished
			case 3: return "failed";    // Failed
			case 4: return "archived";  // Archived
			default: return "pending";
		}
	};

	Func<int, string> GetStatusText = (status) =>
	{
		switch (status)
		{
			case 0: return "Pending";
			case 1: return "Processing";
			case 2: return "Completed";
			case 3: return "Failed";
			case 4: return "Archived";
			default: return "Pending";
		}
	};
}


<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Research Progress Management</title>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
	<link rel="stylesheet" href="~/css/admin/tracking.css" asp-append-version="true" />

</head>
<body data-color-scheme="light">
	<div class="main-container">

		<div class="page-header">
			<h1 class="page-title">
				<i class="fas fa-clipboard-list"></i>
				Research Progress Management
			</h1>
			<p class="page-subtitle">Monitor and update student research submissions across all departments</p>
		</div>

		<!-- Statistics Row -->
		<div class="stats-row">
			<div class="stat-card">
				<div class="stat-number" id="totalSubmissions">6</div>
				<div class="stat-label">Total Submissions</div>
			</div>
			<div class="stat-card">
				<div class="stat-number" id="processingCount">3</div>
				<div class="stat-label">Processing</div>
			</div>
			<div class="stat-card">
				<div class="stat-number" id="completedCount">2</div>
				<div class="stat-label">Complete</div>
			</div>
			<div class="stat-card">
				<div class="stat-number" id="failedCount">1</div>
				<div class="stat-label">Failed</div>
			</div>
		</div>

		<!-- Collapsible Filter Section -->
		<!-- Collapsible Filter Section with Dropdowns and Bulk Actions -->
		<div class="filter-section collapsed" id="filterSection">
			<div class="filter-toggle" id="filterToggle">
				<span class="filter-toggle-text">
					<i class="fas fa-filter"></i>
					Filter & Search
				</span>
				<i class="fas fa-chevron-down filter-toggle-icon"></i>
			</div>
			<div class="filter-content" id="filterContent">
				<!-- Search Input -->
				<div class="search-container">
					<input type="text" class="search-input" id="searchInput" placeholder="Search by name, student number, or service..." />
					<i class="fas fa-search search-icon"></i>
				</div>

				<!-- Filters Grid -->
				<div class="filters-grid">
					<!-- Status Filter (NEW - Dropdown) -->
					<div class="filter-group">
						<label for="statusFilter" class="filter-label">Status:</label>
						<select id="statusFilter" class="filter-dropdown">
							<option value="all">All Statuses</option>
							<option value="processing">Processing</option>
							<option value="complete">Complete</option>
							<option value="failed">Failed</option>
							<option value="archived">Archived</option>
						</select>
					</div>

					<!-- Sort by Date (NEW - Dropdown) -->
					<div class="filter-group">
						<label for="dateSortFilter" class="filter-label">Sort by Date:</label>
						<select id="dateSortFilter" class="filter-dropdown">
							<option value="desc">Newest First</option>
							<option value="asc">Oldest First</option>
						</select>
					</div>

					<!-- Date Range Filter (NEW) -->
					<div class="filter-group date-range-group">
						<label class="filter-label">Date Range:</label>
						<div class="date-range-inputs">
							<input type="date" id="dateFromFilter" class="filter-date-input" />
							<span class="date-separator">to</span>
							<input type="date" id="dateToFilter" class="filter-date-input" />
						</div>
					</div>

					<!-- Department Filter (EXISTING) -->
					<div class="filter-group">
						<label class="filter-label">Department:</label>
						<div class="filter-tabs" id="departmentTabs">
							<!-- Tabs will be populated by JavaScript -->
						</div>
					</div>

					<!-- Service Filter (EXISTING) -->
					<div class="filter-group">
						<label class="filter-label">Service:</label>
						<div class="filter-tabs" id="serviceTabs">
							<!-- Tabs will be populated by JavaScript -->
						</div>
					</div>

					<!-- Clear Filters Button (NEW) -->
					<div class="filter-group">
						<button id="clearFiltersBtn" class="clear-filters-button" type="button">
							<i class="fas fa-redo"></i> Reset Filters
						</button>

					</div>
				</div>
			</div>
		</div>

		<!-- BULK ACTIONS SECTION -->
		<div class="bulk-actions-section" id="bulkActionsSection">
			<div class="bulk-actions-content">
				<div class="selection-count">
					<i class="fas fa-check-square"></i>
					<span id="selectedCount">0</span> submission(s) selected
				</div>

				<div class="bulk-actions-controls">
					<label for="bulkStatusSelect" class="sr-only">Change Status To</label>
					<select id="bulkStatusSelect" class="bulk-status-dropdown" disabled>
						<option value="">Change Status To...</option>
						<option value="1">Processing</option>
						<option value="2">Complete</option>
						<option value="3">Failed</option>
						<option value="4">Archived</option>
					</select>

					<button id="applyBulkStatus" class="apply-bulk-btn" disabled>
						<i class="fas fa-check"></i> Apply
					</button>

					<button id="clearSelections" class="clear-selections-btn" disabled>
						<i class="fas fa-times"></i> Clear
					</button>
				</div>
			</div>
		</div>


		<!-- Students Table Container -->
		<div class="table-wrapper" id="submissionsTableContainer">
			<!-- Table will be populated by JavaScript -->
		</div>

		<!-- Service Steps Modal -->
		<div id="serviceStepsModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3 id="modalTitle">Service Steps</h3>
					<span class="close" onclick="closeServiceStepsModal()">&times;</span>
				</div>
				<div class="modal-body" id="modalBody">
					<!-- Service steps will be populated here -->
				</div>
			</div>
		</div>


		<script>

					const serviceInfoFromDb = @Json.Serialize(Model);

							let currentServiceId = null;
						// Stores the serviceId for the remarks modal
						let currentRemarksServiceId = null;

					// --- HELPER FUNCTIONS ---

					function getStepStatus(progressValue) {
						switch (progressValue) {
							case 1: return "current";
							case 2: return "complete";
							case 3: return "revision";
							case 0:
							default:
								return "pending";
						}
					}

					function convertJsStatusToDbInt(statusString) {
						switch (statusString) {
							case "current": return 1;
							case "complete": return 2;
							case "revision": return 3;
							case "pending":
							default:
								return 0;
						}
					}

					function formatDate(dateString) {
						if (!dateString) return "N/A";
						const date = new Date(dateString);
						return date.toLocaleDateString('en-US', {
							year: 'numeric',
							month: 'short',
							day: 'numeric'
						});
					}

					function getFileIcon(fileName) {
						const ext = fileName.split('.').pop().toLowerCase();
						switch (ext) {
							case 'pdf': return 'fa-file-pdf';
							case 'doc':
							case 'docx': return 'fa-file-word';
							case 'xls':
							case 'xlsx': return 'fa-file-excel';
							case 'png':
							case 'jpg':
							case 'jpeg':
							case 'gif': return 'fa-file-image';
							case 'zip':
							case 'rar': return 'fa-file-archive';
							default: return 'fa-file-alt'; // Default file icon
						}
					}

					// --- DATA TRANSFORMATION ---

							function transformDbData(si) {
								const prog = si.serviceProgress;
						const stepStatuses = [
									getStepStatus(prog.progress1),
									getStepStatus(prog.progress2),
									getStepStatus(prog.progress3),
									getStepStatus(prog.progress4)
								];
						let status = "processing";
								if (stepStatuses.includes("revision")) {
									status = "failed";
						} else if (stepStatuses.every(s => s === "complete")) {
									status = "complete";
						}

								let currentStep = stepStatuses.findIndex(s => s === "current") + 1;
						if (currentStep === 0 && status !== 'complete' && status !== 'failed') {
									currentStep = stepStatuses.findIndex(s => s === "pending") + 1;
						}
								if (currentStep === 0 && status === 'complete') {
									currentStep = stepStatuses.length;
						}

								const serviceKey = si.serviceType.toLowerCase().replace(/ /g, '-');
						const allReceivedFiles = [
									...(prog.progress1files || []),
									...(prog.progress2files || []),
									...(prog.progress3files || []),
									...(prog.progress4files || [])
								];
						const allSentFiles = [
									...(prog.AdminToStudentFiles || [])
								];
						return {
									"id": si.serviceId, // This is the ServiceId
									"name": si.author,
									"studentNumber": si.studentNumber,
									"department": si.subject,
									"course": si.email,
									"service": serviceKey,
									"serviceName": si.serviceType,
									"title": si.title, // <-- **FIX 1: ADDED THIS LINE**
								 "status": status,
									"currentStep": currentStep,
									"totalSteps": 4,
									"runCount": prog.runCount ||
						1,
									"dateSubmitted": prog.appliedDate,
									"lastUpdated": prog.appliedDate,
									"receivedFiles": allReceivedFiles,
									"sendFiles": 0,
									"remarks": prog.remarks ||
						"",
									"stepStatuses": stepStatuses,
											"sendFilesStaged": allSentFiles,
								};
						}

					// --- APPLICATION STATE (RENAMED) ---

					const submissionsFromDb = serviceInfoFromDb.map(transformDbData);
					const departmentsFromDb = [...new Set(submissionsFromDb.map(s => s.department))];
					const servicesFromDb = [...new Map(submissionsFromDb.map(s => [s.service, { key: s.service, name: s.serviceName }])).values()];

					const applicationData = {
						"submissions": submissionsFromDb, // RENAMED
						"departments": departmentsFromDb,
						"services": servicesFromDb,
						"generalStatusTypes": [
							{ "key": "processing", "name": "Processing", "color": "#3b82f6" },
							{ "key": "complete", "name": "Complete", "color": "#10b981" },
							{ "key": "failed", "name": "Failed", "color": "#ef4444" }
						],
						"stepStatusTypes": [
							{ "key": "pending", "name": "PENDING", "color": "#94a3b8" },
							{ "key": "current", "name": "CURRENT", "color": "#3b82f6" },
							{ "key": "complete", "name": "COMPLETE", "color": "#10b981" },
							{ "key": "revision", "name": "REVISION", "color": "#fd7e14" }
						],
						// FIXED: Populated serviceSteps to match your 'showServiceSteps' function
						"serviceSteps": {
							"originality-check": {
								"title": "Originality Check Guide",
								"steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits document (e.g., proposal, final paper).", "processingTime": "N/A" },
									{ "number": 2, "title": "Admin Scan", "details": "Admin runs the document through Turnitin.", "processingTime": "1-2 hours" },
									{ "number": 3, "title": "Review", "details": "Admin reviews the similarity report for issues.", "processingTime": "1 working day" },
									{ "number": 4, "title": "Feedback", "details": "Admin sends the report back to the student with remarks (Pass/Revision).", "processingTime": "1 working day" }
								],
								"note": "Note: A similarity index of 20% or lower is generally required."
							},
							"instrument-validation": {
								"title": "Instrument Validation Guide",
								"steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits validation-ready instrument and list of potential validators.", "processingTime": "N/A" },
									{ "number": 2, "title": "Admin Assigns", "details": "Admin contacts and assigns 3-5 validators.", "processingTime": "2-3 working days" },
									{ "number": 3, "title": "Validation", "details": "Validators provide feedback and scores on the instrument.", "processingTime": "5-7 working days" },
									{ "number": 4, "title": "Analysis", "details": "Admin computes CVI/Cronbach's Alpha and sends results to student.", "processingTime": "1-2 working days" }
								],
								"note": "Note: This service may take longer depending on validator availability."
							},
							// (Add similar data for your other services...)
							"language-editing": {
								"title": "Language Editing Guide",
								 "steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits full manuscript for editing.", "processingTime": "N/A" },
									{ "number": 2, "title": "Assign Editor", "details": "Admin assigns a language editor.", "processingTime": "1 working day" },
									{ "number": 3, "title": "Editing", "details": "Editor provides track-changed document.", "processingTime": "3-5 working days" },
									{ "number": 4, "title": "Final Review", "details": "Admin reviews and sends final edited document to student.", "processingTime": "1 working day" }
								],
								"note": ""
							},
							"data-analysis": {
								"title": "Data Analysis Guide",
								 "steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits raw data (e.g., Excel) and research questions.", "processingTime": "N/A" },
									{ "number": 2, "title": "Assign Statistician", "details": "Admin assigns a statistician.", "processingTime": "1 working day" },
									{ "number": 3, "title": "Analysis", "details": "Statistician performs analysis and prepares results tables.", "processingTime": "3-5 working days" },
									{ "number": 4, "title": "Send Results", "details": "Admin sends completed analysis and interpretation guide.", "processingTime": "1 working day" }
								],
								"note": ""
							},
							"student-research-clearance": {
								"title": "Research Clearance Guide",
								 "steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits completed manuscript and all required forms.", "processingTime": "N/A" },
									{ "number": 2, "title": "Completion Check", "details": "Admin checks for completion of all prior steps (e.g., ethics, editing).", "processingTime": "1-2 working days" },
									{ "number": 3, "title": "Signatures", "details": "Admin forwards for final signatures from department heads.", "processingTime": "2-3 working days" },
									{ "number": 4, "title": "Issue Clearance", "details": "Admin issues the final, signed research clearance document.", "processingTime": "1 working day" }
								],
								"note": ""
							},
							"ethics-review": {
								"title": "Ethics Review Guide",
								 "steps": [
									{ "number": 1, "title": "Submission", "details": "Student submits ethics packet (proposal, consent forms, etc.).", "processingTime": "N/A" },
									{ "number": 2, "title": "Initial Screening", "details": "Admin performs initial screening for completeness.", "processingTime": "1-2 working days" },
									{ "number": 3, "title": "ERB Review", "details": "Ethics Review Board (ERB) reviews the submission.", "processingTime": "5-10 working days" },
									{ "number": 4, "title": "Issue Decision", "details": "ERB issues decision (Approved, Minor Revisions, Full Review).", "processingTime": "1 working day" }
								],
								"note": "Ethics review timelines can vary significantly based on the complexity."
							}
						}
					};

					let currentDepartment = 'all';
					let currentService = 'all';
					let expandedRow = null;
					let filteredSubmissions = [...applicationData.submissions]; // RENAMED
					let currentStatusFilter = 'all';
						let currentSortOrder = 'desc';
						let currentStartDate = null;
						let currentEndDate = null;
						let selectedSubmissionIds = new Set();
					// --- INITIALIZATION ---

					document.addEventListener('DOMContentLoaded', function () {
						initializeApp();
					});

					function initializeApp() {
						setupFilterTabs(); // Setup filters first
						applyFilters(); // This will call renderTable and updateStatistics
						setupEventListeners();

						const filterSection = document.getElementById('filterSection');
						if (filterSection) {
							filterSection.classList.add('collapsed');
						}
					}

					// --- EVENT LISTENERS ---

					function setupEventListeners() {
						const searchInput = document.getElementById('searchInput');
						if (searchInput) {
							searchInput.addEventListener('input', handleSearch);
						}
						const filterToggle = document.getElementById('filterToggle');
						if (filterToggle) {
							filterToggle.addEventListener('click', toggleFilterSection);
						}
					}


				function setupFilterTabs() {
					// Setup Department Dropdown
					const departmentDropdown = document.getElementById('departmentDropdown');
					if (departmentDropdown) {
						// Clear existing options except the first one
						departmentDropdown.innerHTML = '<option value="all">All Departments</option>';
						applicationData.departments.forEach(dept => {
							const option = document.createElement('option');
							option.value = dept;
							option.textContent = dept;
							departmentDropdown.appendChild(option);
						});
						departmentDropdown.value = currentDepartment;
						departmentDropdown.addEventListener('change', (e) => filterByDepartment(e.target.value));
					}

					// Setup Service Dropdown
					const serviceDropdown = document.getElementById('serviceDropdown');
					if (serviceDropdown) {
						serviceDropdown.innerHTML = '<option value="all">All Services</option>';
						applicationData.services.forEach(service => {
							const option = document.createElement('option');
							option.value = service.key;
							option.textContent = service.name;
							serviceDropdown.appendChild(option);
						});
						serviceDropdown.value = currentService;
						serviceDropdown.addEventListener('change', (e) => filterByService(e.target.value));
					}

					// Setup Status Dropdown
					const statusDropdown = document.getElementById('statusDropdown');
					if (statusDropdown) {
						statusDropdown.addEventListener('change', (e) => filterByStatus(e.target.value));
					}

					// Setup Sort Dropdown
					const sortDropdown = document.getElementById('sortDropdown');
					if (sortDropdown) {
						sortDropdown.addEventListener('change', (e) => filterBySort(e.target.value));
					}

					// Setup Date Range Filters
					const startDateFilter = document.getElementById('startDateFilter');
					const endDateFilter = document.getElementById('endDateFilter');
					if (startDateFilter) {
						startDateFilter.addEventListener('change', (e) => {
							currentStartDate = e.target.value;
							applyFilters();
						});
					}
					if (endDateFilter) {
						endDateFilter.addEventListener('change', (e) => {
							currentEndDate = e.target.value;
							applyFilters();
						});
					}

					// Setup Clear Filters Button
					const clearFiltersBtn = document.getElementById('clearFiltersBtn');
					if (clearFiltersBtn) {
						clearFiltersBtn.addEventListener('click', clearAllFilters);
					}
				}

					// --- FILTERING & SEARCH (RENAMED) ---

					function handleSearch(event) {
						const searchTerm = event.target.value.toLowerCase().trim();
						let baseList = [...applicationData.submissions];

						if (searchTerm !== '') {
							baseList = applicationData.submissions.filter(submission => { // RENAMED
								return submission.name.toLowerCase().includes(searchTerm) ||
									submission.studentNumber.toLowerCase().includes(searchTerm) ||
									submission.serviceName.toLowerCase().includes(searchTerm) ||
									submission.department.toLowerCase().includes(searchTerm);
							});
						}
						// Store the search-filtered list globally before applying tab filters
						filteredSubmissions = baseList;
						applyFilters();
					}

					function filterByDepartment(department) {
						currentDepartment = department;
						document.querySelectorAll('#departmentTabs .filter-tab').forEach(tab => {
							tab.classList.toggle('active', tab.getAttribute('data-value') === department);
						});
						applyFilters();
					}

					function filterByService(service) {
						currentService = service;
						document.querySelectorAll('#serviceTabs .filter-tab').forEach(tab => {
							tab.classList.toggle('active', tab.getAttribute('data-value') === service);
						});
						applyFilters();
					}
							function filterByStatus(status) {
							currentStatusFilter = status;
							applyFilters();
						}

						function filterBySort(order) {
							currentSortOrder = order;
							applyFilters();
						}

								function clearAllFilters() {
							currentDepartment = 'all';
							currentService = 'all';
							currentStatusFilter = 'all';
							currentSortOrder = 'desc';
							currentStartDate = null;
							currentEndDate = null;

							document.getElementById('departmentDropdown').value = 'all';
							document.getElementById('serviceDropdown').value = 'all';
							document.getElementById('statusDropdown').value = 'all';
							document.getElementById('sortDropdown').value = 'desc';
							document.getElementById('startDateFilter').value = '';
							document.getElementById('endDateFilter').value = '';
							document.getElementById('searchInput').value = '';

							filteredSubmissions = [...applicationData.submissions];
							applyFilters();
						}

							function applyFilters() {
							// Start from the latest search-filtered list
							let filtered = [...filteredSubmissions];

							// Department filter
							if (currentDepartment !== 'all') {
								filtered = filtered.filter(submission => submission.department === currentDepartment);
							}

							// Service filter
							if (currentService !== 'all') {
								filtered = filtered.filter(submission => submission.service === currentService);
							}

							// Status filter - IMPORTANT: Archive handling
							if (currentStatusFilter === 'all') {
								// When "all" is selected, exclude archived items
								filtered = filtered.filter(submission => submission.status !== 'archived');
							} else {
								// When a specific status is selected, show only that status
								filtered = filtered.filter(submission => submission.status === currentStatusFilter);
							}

							// Date range filter
							if (currentStartDate) {
								filtered = filtered.filter(submission => {
									const submissionDate = new Date(submission.dateSubmitted).toISOString().split('T')[0];
									return submissionDate >= currentStartDate;
								});
							}
							if (currentEndDate) {
								filtered = filtered.filter(submission => {
									const submissionDate = new Date(submission.dateSubmitted).toISOString().split('T')[0];
									return submissionDate <= currentEndDate;
								});
							}

							// Sort by date
							filtered.sort((a, b) => {
								const dateA = new Date(a.dateSubmitted);
								const dateB = new Date(b.dateSubmitted);
								return currentSortOrder === 'asc' ? dateA - dateB : dateB - dateA;
							});

							renderTable(filtered);
							updateStatistics(applicationData.submissions);
						}


									// ===============================
			// BULK UPDATE FUNCTIONALITY
			// ===============================

			// Track selected submission IDs
			let selectedSubmissions = new Set();

			// Initialize when document loads
			document.addEventListener('DOMContentLoaded', function() {
				initializeBulkActions();
			});

			function initializeBulkActions() {
				// Setup Select All checkbox
				const selectAllCheckbox = document.getElementById('selectAllCheckbox');
				if (selectAllCheckbox) {
					selectAllCheckbox.addEventListener('change', handleSelectAll);
				}

				// Setup individual checkboxes (will be called after table renders)
				attachCheckboxListeners();

				// Setup Apply button
				const applyBtn = document.getElementById('applyBulkStatus');
				if (applyBtn) {
					applyBtn.addEventListener('click', applyBulkStatusUpdate);
				}

				// Setup Clear button
				const clearBtn = document.getElementById('clearSelections');
				if (clearBtn) {
					clearBtn.addEventListener('click', clearAllSelections);
				}

				updateBulkActionsUI();
			}

			// Attach listeners to checkboxes (call this after rendering table)
			function attachCheckboxListeners() {
				document.querySelectorAll('.bulk-checkbox').forEach(checkbox => {
					checkbox.removeEventListener('change', handleIndividualCheckbox); // Prevent duplicates
					checkbox.addEventListener('change', handleIndividualCheckbox);
				});
			}

			// Handle Select All checkbox
			function handleSelectAll(event) {
				const isChecked = event.target.checked;
				const checkboxes = document.querySelectorAll('.bulk-checkbox');

				checkboxes.forEach(checkbox => {
					checkbox.checked = isChecked;
					const submissionId = checkbox.getAttribute('data-id');

					if (isChecked) {
						selectedSubmissions.add(submissionId);
					} else {
						selectedSubmissions.delete(submissionId);
					}
				});

				updateBulkActionsUI();
			}

			// Handle individual checkbox selection
			function handleIndividualCheckbox(event) {
				const submissionId = event.target.getAttribute('data-id');

				if (event.target.checked) {
					selectedSubmissions.add(submissionId);
				} else {
					selectedSubmissions.delete(submissionId);
				}

				// Update "Select All" checkbox state
				updateSelectAllCheckbox();
				updateBulkActionsUI();
			}

			// Update Select All checkbox based on individual selections
			function updateSelectAllCheckbox() {
				const selectAllCheckbox = document.getElementById('selectAllCheckbox');
				const allCheckboxes = document.querySelectorAll('.bulk-checkbox');
				const checkedCheckboxes = document.querySelectorAll('.bulk-checkbox:checked');

				if (selectAllCheckbox) {
					selectAllCheckbox.checked = allCheckboxes.length > 0 &&
												 allCheckboxes.length === checkedCheckboxes.length;
					selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 &&
													  checkedCheckboxes.length < allCheckboxes.length;
				}
			}

			// Update the bulk actions UI (selection count and button states)
			function updateBulkActionsUI() {
				const count = selectedSubmissions.size;
				const countElement = document.getElementById('selectedCount');
				const applyBtn = document.getElementById('applyBulkStatus');
				const clearBtn = document.getElementById('clearSelections');
				const bulkStatusSelect = document.getElementById('bulkStatusSelect');

				if (countElement) {
					countElement.textContent = count;
				}

				// Enable/disable buttons based on selection
				if (applyBtn) {
					applyBtn.disabled = count === 0;
				}
				if (clearBtn) {
					clearBtn.disabled = count === 0;
				}
				if (bulkStatusSelect) {
					bulkStatusSelect.disabled = count === 0;
				}
			}

			// Apply bulk status update
			async function applyBulkStatusUpdate() {
				const count = selectedSubmissions.size;

				if (count === 0) {
					showNotification('Please select at least one submission', 'warning');
					return;
				}

				const statusSelect = document.getElementById('bulkStatusSelect');
				const selectedStatus = statusSelect.value;

				if (!selectedStatus) {
					showNotification('Please select a status', 'warning');
					return;
				}

				// Get status text for confirmation
				const statusText = statusSelect.options[statusSelect.selectedIndex].text;

				// Show confirmation modal
				const confirmed = await showConfirmationModal(
					`Are you sure you want to update ${count} submission(s) to "${statusText}"?`,
					'This action will change the status of all selected submissions.'
				);

				if (!confirmed) {
					return;
				}

				// Prepare data
				const idsArray = Array.from(selectedSubmissions);
				const idsString = idsArray.join(',');

				// Get anti-forgery token
				const token = document.querySelector('input[name="__RequestVerificationToken"]').value;

				try {
					// Show loading state
					showNotification('Updating submissions...', 'info');

					const response = await fetch('/Admin/BulkUpdateStatus', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'RequestVerificationToken': token
						},
						body: JSON.stringify({
							Ids: idsString,
							Status: selectedStatus
						})
					});

					const result = await response.json();

					if (result.success) {
						showNotification(result.message || 'Submissions updated successfully', 'success');

						// Clear selections
						clearAllSelections();

						// Reload the page to show updated data
						setTimeout(() => {
							location.reload();
						}, 1500);
					} else {
						showNotification(result.message || 'Failed to update submissions', 'error');
					}
				} catch (error) {
					console.error('Error updating submissions:', error);
					showNotification('An error occurred while updating submissions', 'error');
				}
			}

			// Clear all selections
			function clearAllSelections() {
				selectedSubmissions.clear();

				// Uncheck all checkboxes
				document.querySelectorAll('.bulk-checkbox').forEach(checkbox => {
					checkbox.checked = false;
				});

				const selectAllCheckbox = document.getElementById('selectAllCheckbox');
				if (selectAllCheckbox) {
					selectAllCheckbox.checked = false;
					selectAllCheckbox.indeterminate = false;
				}

				// Reset status dropdown
				const statusSelect = document.getElementById('bulkStatusSelect');
				if (statusSelect) {
					statusSelect.value = '';
				}

				updateBulkActionsUI();
			}

			// Show confirmation modal
			function showConfirmationModal(title, message) {
				return new Promise((resolve) => {
					// Create modal overlay
					const overlay = document.createElement('div');
					overlay.className = 'custom-modal-overlay';
					overlay.style.display = 'flex';

					// Create modal content
					overlay.innerHTML = `
						<div class="custom-modal-content">
							<h3 style="margin-bottom: 1rem; color: var(--primary-blue);">${title}</h3>
							<p class="custom-modal-message">${message}</p>
							<div class="custom-modal-buttons">
								<button class="custom-modal-button confirm">Confirm</button>
								<button class="custom-modal-button cancel">Cancel</button>
							</div>
						</div>
					`;

					document.body.appendChild(overlay);

					// Handle button clicks
					const confirmBtn = overlay.querySelector('.confirm');
					const cancelBtn = overlay.querySelector('.cancel');

					confirmBtn.addEventListener('click', () => {
						document.body.removeChild(overlay);
						resolve(true);
					});

					cancelBtn.addEventListener('click', () => {
						document.body.removeChild(overlay);
						resolve(false);
					});

					// Close on overlay click
					overlay.addEventListener('click', (e) => {
						if (e.target === overlay) {
							document.body.removeChild(overlay);
							resolve(false);
						}
					});
				});
			}

			// Show notification
			function showNotification(message, type = 'info') {
				// Create notification element
				const notification = document.createElement('div');
				notification.style.cssText = `
					position: fixed;
					top: 20px;
					right: 20px;
					padding: 1rem 1.5rem;
					background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
					color: white;
					border-radius: 8px;
					box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
					z-index: 10000;
					font-weight: 500;
					animation: slideInRight 0.3s ease;
				`;
				notification.textContent = message;

				document.body.appendChild(notification);

				// Remove after 3 seconds
				setTimeout(() => {
					notification.style.animation = 'slideOutRight 0.3s ease';
					setTimeout(() => {
						if (document.body.contains(notification)) {
							document.body.removeChild(notification);
						}
					}, 300);
				}, 3000);
			}


						// After rendering the table
			document.getElementById('submissionsTableBody').innerHTML = tableHTML;
			attachCheckboxListeners(); // Re-attach listeners to new checkboxes



					// --- TABLE RENDERING (RENAMED) ---

					function renderTable(submissions = applicationData.submissions) { // RENAMED
						// RENAMED ID
						const tableContainer = document.getElementById('submissionsTableContainer');
						if (!tableContainer) return;

						const table = `
							<div class="table-container">
								<div class="table-header">
									<h3 class="table-title">
										<i class="fas fa-users"></i>
										Research Submissions (${submissions.length})
									</h3>
								</div>
								<table class="students-table">
									<thead>
										<tr>
											<th style="width:50px;text-align:center;">
												<input
													type="checkbox"
													id="selectAllCheckbox"
													style="width:18px;height:18px;cursor:pointer;"
													title="Select All"
												/>
											</th>
											<th>Author(s)</th>
											<th>Subject</th>
											<th>Research Title</th>
											<th>Department</th>
											<th>Service</th>
											<th>Status</th>
											<th>Progress</th>
											<th>Last Updated</th>
											<th>Guide</th>
										</tr>
									</thead>
									<tbody>

										${submissions.length > 0 ?
											submissions.map(submission => createSubmissionRow(submission)).join('') : // RENAMED
											'<tr><td colspan="7" style="text-align:center; padding: 2rem; color: #6b7280;">No submissions found.</td></tr>'
										}
									</tbody>
								</table>
							</div>
						`;

						tableContainer.innerHTML = table;
					}

									function createSubmissionRow(submission) { // RENAMED
										const isComplete = submission.status === 'complete';
										const currentStepForProgress = isComplete ? submission.totalSteps : submission.currentStep;
										const progressPercentage = Math.round((currentStepForProgress / submission.totalSteps) * 100);
										const statusClass = `status-${submission.status}`;
										const initials = submission.name.split(' ').map(n => n[0]).join('').substring(0, 2);
										
										return `
												<tr class="student-row" onclick="toggleSubmissionDetails('${submission.id}')" data-service-id="${submission.id}">

											<td onclick="event.stopPropagation();" style="text-align:center;">
											<input
												type="checkbox"
												class="bulk-checkbox"
												data-id="${submission.id}"
												style="width:18px;height:18px;cursor:pointer;"
											/>
										</td>
											<td>
												<div class="student-info">
													<div class="student-avatar">${initials}
													</div>
													<div class="student-details">
														<h4>${submission.name}</h4>
														<p>${submission.studentNumber} • ${submission.course}</p>
													</div>
												</div>
											</td>
											<td>
												<span class="department-text">${submission.department}</span>
											</td>
											<td>
												<span class="department-text">${submission.title}</span>
											</td>
											<td>
												<span class="department-text">${submission.department}</span>
											</td>
											<td>
												<span class="service-badge">${submission.serviceName}</span>
											</td>
											<td>
												<span class="status-badge ${statusClass}">${submission.status}</span>
											</td>
											<td>
												<div class="progress-container">
													<div class="progress-bar">
														<div class="progress-fill ${statusClass}" style="width: ${progressPercentage}%">
														</div>
													</div>
													<div class="progress-text">${currentStepForProgress}/${submission.totalSteps} steps
													</div>
												</div>
											</td>
											<td>${formatDate(submission.lastUpdated)}</td>
											<td>
												 <button class="action-btn info-btn" onclick="event.stopPropagation();
								showServiceSteps('${submission.service}')" title="View Service Steps">
														<i class="fas fa-info-circle"></i>
													</button>
											</td>

											</tr>

										<tr class="expanded-content hidden" id="expanded-${submission.id}">
											<td colspan="10">
												${createExpandedContent(submission)}
											</td>
										</tr>
															`;
														}

							function createExpandedContent(submission) { // RENAMED


							const safeSeparator = '\u001F';
							let remarkAuthor = "admin"; // Default author

							// Default message is the full, original remark string
							let remarkMessage = submission.remarks;

							// Check if the remark string is valid and contains the separator
							if (submission.remarks && submission.remarks.includes(safeSeparator)) {

								// Split the string by the separator and trim whitespace
								const parts = submission.remarks.split(safeSeparator).map(part => part.trim());

								// If split is successful, overwrite the defaults
								if (parts.length >= 2) {
									remarkAuthor = parts[0];   // The author is now in this variable
									remarkMessage = parts[1];  // The message is now in this variable
								}
							}

							// Now, 'remarkAuthor' and 'remarkMessage' can be used in the template.
							// --- End Fix ---

							return `
								<div class="expanded-inner">
									<div class="control-section">
										<div class="section-header">
											<i class="fas fa-cogs"></i>
											Progress Control
										</div>

										<div class="progress-controls">
											<div class="control-group">
												<label class="control-label">General Status:</label>
												<select class="status-select" onchange="updateGeneralStatus('${submission.id}', this.value)">
													${applicationData.generalStatusTypes.map(status =>
														`<option value="${status.key}" ${submission.status === status.key ? 'selected' : ''}>
															${status.name}
														</option>`
													).join('')}
												</select>
											</div>

											<div class="control-group">
												<label class="control-label">Run Count:</label>
												<div class="run-count-controls">
													<button class="run-count-btn" onclick="updateRunCount('${submission.id}', -1)">
														<i class="fas fa-minus"></i>
													</button>
													<span class="run-count-display" id="runCount-${submission.id}">${submission.runCount}</span>
													<button class="run-count-btn" onclick="updateRunCount('${submission.id}', 1)">
														<i class="fas fa-plus"></i>
													</button>
												</div>
											</div>
										</div>

										<div class="step-management">
											<div class="section-header">
												<i class="fas fa-list-ol"></i>
												Step Management
											</div>

											<div class="step-indicator">
												${submission.stepStatuses.map((status, index) =>
													`<div class="step-dot ${status}" title="Step ${index + 1}: ${status.toUpperCase()}">${index + 1}</div>`
												).join('')}
											</div>

											<div class="step-status-controls">
												${submission.stepStatuses.map((status, index) => `
													<div class="step-status-item">
														<span class="step-label">Step ${index + 1}:</span>
														<select class="step-status-select" onchange="updateStepStatus('${submission.id}', ${index}, this.value)">
															${applicationData.stepStatusTypes.map(stepStatus =>
																`<option value="${stepStatus.key}" ${status === stepStatus.key ? 'selected' : ''}>
																	${stepStatus.name}
																</option>`
															).join('')}
														</select>
													</div>
												`).join('')}
											</div>
										</div>
									</div>

									<div class="control-section">
										<div class="section-header">
											<i class="fas fa-folder-open"></i>
											File Management
										</div>

										<div class="file-tabs">
											<button class="file-tab active" onclick="switchFileTab(event, '${submission.id}', 'received')">
												Received Files <span class="file-count">${submission.receivedFiles.length}</span>
											</button>
											<button class="file-tab" onclick="switchFileTab(event, '${submission.id}', 'send')">
												Send to Student <span class="file-count" id="send-file-count-${submission.id}">${submission.sendFiles}</span>
											</button>
										</div>

										<div class="file-content" id="fileContent-${submission.id}">
											${createReceivedFilesContent(submission)}
										</div>

										<div class="section-header" style="margin-top: 1.5rem;">
											<i class="fas fa-comment-alt"></i>
											Remarks
										</div>

										<textarea class="remarks-textarea" placeholder="Add remarks..." onchange="updateRemarks('${submission.id}', this.value)">${remarkMessage}</textarea>

										<div class="action-buttons">
											<button class="action-btn btn-primary" onclick="saveChanges(${submission.id})">
												<i class="fas fa-save"></i> Save Changes
											</button>
											<button class="action-btn btn-secondary" onclick="toggleSubmissionDetails('${submission.id}')">
												<i class="fas fa-times"></i> Close
											</button>
										</div>
									</div>
								</div>
							`;
						}

					function createReceivedFilesContent(submission) { // RENAMED
						return `
							<div class="file-list">
								${submission.receivedFiles.length > 0 ?
									submission.receivedFiles.map((fileName, index) => `
										<div class="file-item">
											<div class="file-icon">
												<i class="fas ${getFileIcon(fileName)}"></i>
											</div>
											<div class="file-info">
												<div class="file-name">${fileName}</div>
											</div>
											<div class="file-actions">
												<a href="/uploads/Service_${submission.id}/${fileName}" class="file-action-btn btn-download" title="Download ${fileName}" download>
													<i class="fas fa-download"></i>
												</a>
											</div>
										</div>
									`).join('') :
									'<p style="text-align: center; color: #6b7280; padding: 2rem;">No files received yet</p>'
								}
							</div>
						`;
					}
							function createSendFilesContent(submission) { // RENAMED
								return `
									<div class="drag-drop-area" onclick="document.getElementById('fileInput-${submission.id}').click()">
										<div class="drag-drop-text">
											<i class="fas fa-cloud-upload-alt" style="font-size: 2rem; margin-bottom: 1rem; color: #3b82f6;"></i><br>
											Click to upload files
						or drag and drop<br>
											<small>PDF, DOC, DOCX files up to 10MB</small>
										</div>
										<input type="file" id="fileInput-${submission.id}" multiple accept=".pdf,.doc,.docx" style="display: none;"
						onchange="handleFileUpload('${submission.id}', this.files)">
									</div>
									<div class="file-list" id="send-file-list-${submission.id}">
										${createStagedFileList(submission)}
									</div>
								`;
						}

					function setupTableEventListeners() {
						// This was empty in your file, so I've left it
					}

					// --- UI INTERACTIONS (RENAMED) ---

				   function toggleSubmissionDetails(serviceId) {
					const expandedRowElement = document.getElementById(`expanded-${serviceId}`);
					const submissionRow = document.querySelector(`[data-service-id="${serviceId}"]`);

					if (expandedRowElement && submissionRow) {
						const isExpanded = !expandedRowElement.classList.contains('hidden');

						// Close all others
						document.querySelectorAll('.expanded-content').forEach(row => {
							row.classList.add('hidden');
						});
						document.querySelectorAll('.student-row').forEach(row => {
							row.classList.remove('expanded');
						});

						// Toggle this one
						if (!isExpanded) {
							expandedRowElement.classList.remove('hidden');
							submissionRow.classList.add('expanded');
							expandedRow = serviceId; // Store just the ID
						} else {
							expandedRow = null;
						}
					}
				}

					function switchFileTab(event, serviceId, tabType) { // RENAMED
						const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
						if (!submission) return;

						// Update tab states
						const tabContainer = event.currentTarget.parentElement;
						tabContainer.querySelectorAll('.file-tab').forEach(tab => tab.classList.remove('active'));
						event.currentTarget.classList.add('active');

						// Update content
						const contentContainer = document.getElementById(`fileContent-${serviceId}`);
						if (contentContainer) {
							if (tabType === 'received') {
								contentContainer.innerHTML = createReceivedFilesContent(submission);
							} else {
								contentContainer.innerHTML = createSendFilesContent(submission);
							}
						}
					}

					// --- LOCAL DATA UPDATES (RENAMED) ---

					function updateGeneralStatus(serviceId, newStatus) { // RENAMED
							 const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId)); // RENAMED
						if (submission) {
							submission.status = newStatus;
							submission.lastUpdated = new Date().toISOString(); // More precise

							// Auto-update steps based on general status
							if (newStatus === 'complete') {
								submission.stepStatuses = submission.stepStatuses.map(() => 'complete');
							} else if (newStatus === 'failed') {
								const revisionIndex = submission.stepStatuses.findIndex(s => s !== 'complete');
								if (revisionIndex !== -1) {
									submission.stepStatuses[revisionIndex] = 'revision';
								}
							} else if (newStatus === 'processing') {
								 // If moving from failed/complete back to processing, set first non-complete to 'current'
								 const currentIndex = submission.stepStatuses.findIndex(s => s === 'current');
								 if (currentIndex === -1) {
									const firstPending = submission.stepStatuses.findIndex(s => s === 'pending' || s === 'revision');
									if (firstPending !== -1) {
										submission.stepStatuses[firstPending] = 'current';
									}
								 }
							}

							// Re-render the table to reflect changes (applyFilters re-applies search/tabs)
							const currentSearch = document.getElementById('searchInput').value;
							handleSearch({ target: { value: currentSearch } }); // This re-runs search and applyFilters


						}
					}

					function updateRunCount(serviceId, delta) { // RENAMED
						const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
						if (submission) {
							const newCount = Math.max(1, (submission.runCount || 1) + delta); // Default to 1, min 1
							submission.runCount = newCount;

							const display = document.getElementById(`runCount-${serviceId}`);
							if (display) {
								display.textContent = newCount;
							}
						}
					}

					function updateStepStatus(serviceId, stepIndex, newStatus) { // RENAMED
						const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
						if (submission && stepIndex >= 0 && stepIndex < submission.stepStatuses.length) {
							submission.stepStatuses[stepIndex] = newStatus;

							// Auto-update general status
							if (submission.stepStatuses.includes("revision")) {
								submission.status = "processing";
							} else if (submission.stepStatuses.every(s => s === "complete")) {
								submission.status = "complete";
							} else {
								submission.status = "processing";
							}

							// Update the general status dropdown in the expanded view
							const statusSelect = document.querySelector(`#expanded-${serviceId} .status-select`);
							if (statusSelect) {
								statusSelect.value = submission.status;
							}

							// Update the visual indicator
							const stepDot = document.querySelector(`#expanded-${serviceId} .step-dot:nth-child(${stepIndex + 1})`);
							if (stepDot) {
								stepDot.className = `step-dot ${newStatus}`;
								stepDot.title = `Step ${stepIndex + 1}: ${newStatus.toUpperCase()}`;
							}

							// Find and update the main row in the table without a full re-render
							const mainRow = document.querySelector(`[data-service-id="${serviceId}"]`);
							if (mainRow) {
								 // Update status badge
								const statusBadge = mainRow.querySelector('.status-badge');
								if (statusBadge) {
									statusBadge.className = `status-badge status-${submission.status}`;
									statusBadge.textContent = submission.status;
								}
								// Update progress bar
								const isComplete = submission.status === 'complete';
								const currentStepForProgress = isComplete ? submission.totalSteps : submission.currentStep;
								const progressPercentage = Math.round((currentStepForProgress / submission.totalSteps) * 100);

								const progressFill = mainRow.querySelector('.progress-fill');
								if (progressFill) {
									progressFill.className = `progress-fill status-${submission.status}`;
									progressFill.style.width = `${progressPercentage}%`;
								}
								const progressText = mainRow.querySelector('.progress-text');
								if (progressText) {
									progressText.textContent = `${currentStepForProgress}/${submission.totalSteps} steps`;
								}
							}
							// Update global stats
							updateStatistics(applicationData.submissions);
						}
					}

					function updateRemarks(serviceId, remarks) { // RENAMED
						const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));// RENAMED
						if (submission) {
							submission.remarks = remarks;
						}
					}

							function handleFileUpload(serviceId, files) {
								// FIX 2: Use parseInt for consistent lookup
								const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
								if (!submission) return;

								// Convert FileList to an array and append to the staged list
								const newFiles = Array.from(files);
								submission.sendFilesStaged.push(...newFiles); // Store the actual File objects

								// Update the visual count in the tab
								const fileCountSpan = document.getElementById(`send-file-count-${serviceId}`);
								if (fileCountSpan) {
									fileCountSpan.textContent = submission.sendFilesStaged.length;
								}

								// Re-render the file list using the updated staged data
								const fileList = document.getElementById(`send-file-list-${serviceId}`);
								if (fileList) {
									fileList.innerHTML = createStagedFileList(submission);
								}

								// Clear the file input's value so the same file can be selected again
								const fileInput = document.getElementById(`fileInput-${serviceId}`);
								if (fileInput) {
									 fileInput.value = '';
								}
							}
					// --- SERVER COMMUNICATION (RENAMED) ---

					   async function saveChanges(serviceId) {
					const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
					if (!submission) {
						alert('Error: Could not find submission data.');
						return;
					}

					const saveButton = document.querySelector(`#expanded-${serviceId} .btn-primary`);
					if (saveButton) {
						saveButton.disabled = true;
						saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
					}

					// 1. CREATE A FORM DATA OBJECT
					const formData = new FormData();

					// 2. APPEND ALL TEXT/DATA FIELDS
					var remarks = "@currentUser.FirstName" + " " + "@currentUser.LastName" + "\u001F" + submission.remarks;

					formData.append('serviceId', submission.id);
					formData.append('progress1', convertJsStatusToDbInt(submission.stepStatuses[0]));
					formData.append('progress2', convertJsStatusToDbInt(submission.stepStatuses[1]));
					formData.append('progress3', convertJsStatusToDbInt(submission.stepStatuses[2]));
					formData.append('progress4', convertJsStatusToDbInt(submission.stepStatuses[3]));
					formData.append('runCount', submission.runCount);
					formData.append('remarks', remarks);

					// 3. APPEND ALL STAGED FILES (Crucial step)
					if (submission.sendFilesStaged.length > 0) {
						submission.sendFilesStaged.forEach(file => {
							// The server-side controller action must expect files under the key 'files'
							formData.append('files', file, file.name);
						});
					}

					console.log('--- Payload Sent to Server (FormData) ---');
					// Note: You cannot easily log FormData contents, but this shows the intent.
					// console.log(formData);

					try {
						const response = await fetch('/Admin/UpdateProgress', {
							method: 'POST',
							// IMPORTANT: DO NOT set Content-Type header for FormData.
							// The browser will set 'multipart/form-data' automatically, including the boundary.
							// headers: {
							//     // 'Content-Type': 'application/json', <--- REMOVE THIS!
							// },
							body: formData // Send the FormData object
						});

						if (response.ok) {
							const result = await response.json();
							console.log('Save successful', result);
							alert('Changes saved successfully! Files have been sent to the server.');

							submission.lastUpdated = new Date().toISOString();

							// IMPORTANT: Clear the staged files array after a successful save
							submission.sendFilesStaged = [];
							// Re-render the file list and update the tab count
							document.getElementById(`send-file-list-${serviceId}`).innerHTML = createStagedFileList(submission);
							document.getElementById(`send-file-count-${serviceId}`).textContent = '0';


							// Update the 'Last Updated' cell in the main row
							const mainRow = document.querySelector(`[data-service-id="${serviceId}"]`);
							if(mainRow) {
								const dateCell = mainRow.cells[5]; // 6th cell (index 5)
								if(dateCell) {
									dateCell.textContent = formatDate(submission.lastUpdated);
								}
							}

						} else {
							const errorText = await response.text();
							console.error('Save failed:', errorText);
							alert(`Error: Could not save changes. Server said: ${errorText}`);
						}
					} catch (error) {
						console.error('Error saving changes:', error);
						alert('Error: A network error occurred while saving.');
					} finally {
						if (saveButton) {
							saveButton.disabled = false;
							saveButton.innerHTML = '<i class="fas fa-save"></i> Save Changes';
						}
					}
				}

					// --- STATS & MODAL (RENAMED) ---

					function updateStatistics(submissions = applicationData.submissions) { // RENAMED
						const stats = {
							total: submissions.length,
							processing: submissions.filter(s => s.status === 'processing').length,
							complete: submissions.filter(s => s.status === 'complete').length,
							failed: submissions.filter(s => s.status === 'failed').length
						};

						// RENAMED ID
						const elements = {
							totalSubmissions: document.getElementById('totalSubmissions'),
							processingCount: document.getElementById('processingCount'),
							completedCount: document.getElementById('completedCount'),
							failedCount: document.getElementById('failedCount')
						};

						if (elements.totalSubmissions) elements.totalSubmissions.textContent = stats.total;
						if (elements.processingCount) elements.processingCount.textContent = stats.processing;
						if (elements.completedCount) elements.completedCount.textContent = stats.complete;
						if (elements.failedCount) elements.failedCount.textContent = stats.failed;
					}


					function showServiceSteps(serviceKey) {
						const modal = document.getElementById('serviceStepsModal');
						const modalTitle = document.getElementById('modalTitle');
						const modalBody = document.getElementById('modalBody');

						const serviceData = applicationData.serviceSteps[serviceKey];
						if (!serviceData || !serviceData.steps) {
							console.warn(`No service step data found for key: ${serviceKey}`);
							modalTitle.textContent = "Guide Not Available";
							modalBody.innerHTML = "<p>The guide for this service has not been set up yet.</p>";
						} else {
							modalTitle.textContent = serviceData.title;

							let stepsHTML = '<div class="service-steps-container">';
							serviceData.steps.forEach(step => {
								stepsHTML += `
									<div class="service-step-item">
										<div class="service-step-number">${step.number}</div>
										<div class="service-step-content">
											<h4 class="service-step-title">${step.title}</h4>
											<div class="service-step-details">${step.details}</div>
											<div class="service-step-time"><strong>Processing Time:</strong> ${step.processingTime}</div>
										</div>
									</div>
								`;
							});
							stepsHTML += '</div>';

							if (serviceData.note) {
								stepsHTML += `<div class="service-note"><strong>Note:</strong> ${serviceData.note}</div>`;
							}

							stepsHTML += '<div class="service-end-transaction">END OF TRANSACTION</div>';
							modalBody.innerHTML = stepsHTML;
						}

						modal.style.display = 'block';

						// Close modal when clicking outside
						modal.onclick = function (event) {
							if (event.target === modal) {
								closeServiceStepsModal();
							}
						};
					}
							// --- NEW HELPER: Renders the list of staged files ---
							function createStagedFileList(submission) {
								if (!submission.sendFilesStaged || submission.sendFilesStaged.length === 0) {
									return '<p style="text-align: center; color: #6b7280; padding: 1rem;">No files staged for sending</p>';
								}

								// Use the index from the array for the remove function
								return submission.sendFilesStaged.map((file, index) => `
									<div class="file-item staged-file">
										<div class="file-icon"><i class="fas ${getFileIcon(file.name)}"></i></div>
										<div class="file-info">
											<div class="file-name">${file.name}</div>
											<div class="file-size">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
										</div>
										<div class="file-actions">
											<button class="file-action-btn btn-delete" title="Remove"
													onclick="removeStagedFile('${submission.id}', ${index}, this)">
												<i class="fas fa-trash"></i>
											</button>
										</div>
									</div>
								`).join('');
							}

							// --- NEW HELPER: Removes a staged file from the local array and UI ---
							function removeStagedFile(serviceId, index, element) {
								const submission = applicationData.submissions.find(s => s.id === parseInt(serviceId));
								if (!submission) return;

								// Remove the file from the array
								submission.sendFilesStaged.splice(index, 1);

								// Update the visual count in the tab
								const fileCountSpan = document.getElementById(`send-file-count-${serviceId}`);
								if (fileCountSpan) {
									fileCountSpan.textContent = submission.sendFilesStaged.length;
								}

								// Remove the file item element from the DOM
								element.closest('.file-item').remove();

								// If the list is now empty, re-render the "No files" message
								if (submission.sendFilesStaged.length === 0) {
									const fileList = document.getElementById(`send-file-list-${serviceId}`);
									if (fileList) {
										 fileList.innerHTML = '<p style="text-align: center; color: #6b7280; padding: 1rem;">No files staged for sending</p>';
									}
								}

								// Re-render the tab content to regenerate the file list with correct indices
								// when the user removes a file, making the list display accurate.
								const contentContainer = document.getElementById(`fileContent-${serviceId}`);
								if (contentContainer) {
									 contentContainer.innerHTML = createSendFilesContent(submission);
								}

								// Re-activate the 'Send to Student' tab button visually after re-render
								const tabContainer = document.querySelector(`#fileContent-${serviceId}`).parentElement.querySelector('.file-tabs');
								if(tabContainer) {
									tabContainer.querySelectorAll('.file-tab').forEach(tab => tab.classList.remove('active'));
									tabContainer.querySelectorAll('.file-tab')[1].classList.add('active'); // Second tab is 'Send to Student'
								}
							}
					// FIXED: Completed this function
					function closeServiceStepsModal() {
						const modal = document.getElementById('serviceStepsModal');
						if (modal) {
							modal.style.display = 'none';
						}
					}


							document.addEventListener('DOMContentLoaded', function () {

									// --- New Filter Logic ---
									const applyFilterBtn = document.getElementById('apply-filter-btn');
									if (applyFilterBtn) {
										applyFilterBtn.addEventListener('click', filterAndSortTable);
									}

									function filterAndSortTable() {
										const statusFilter = document.getElementById('status-filter').value;
										const sortOrder = document.getElementById('sort-filter').value;
										const startDate = document.getElementById('start-date').value;
										const endDate = document.getElementById('end-date').value;

										const tableBody = document.getElementById('submissions-tbody');
										const rows = Array.from(tableBody.querySelectorAll('tr[data-status]'));

										// 1. Filter rows
										let filteredRows = rows.filter(row => {
											const status = row.dataset.status;
											const date = row.dataset.date;

											// Status filter logic
											let statusMatch = false;
											if (statusFilter === 'all') {
												// "All" excludes "Archived" (status 4)
												statusMatch = status !== '4';
											} else {
												// Specific status match
												statusMatch = status === statusFilter;
											}

											// Date range filter logic
											let dateMatch = true; // Assume true if no dates are set
											if (startDate && date < startDate) {
												dateMatch = false;
											}
											if (endDate && date > endDate) {
												dateMatch = false;
											}

											return statusMatch && dateMatch;
										});

										// 2. Sort filtered rows
										filteredRows.sort((a, b) => {
											const dateA = new Date(a.dataset.date);
											const dateB = new Date(b.dataset.date);

											if (sortOrder === 'asc') {
												return dateA - dateB;
											} else {
												return dateB - dateA; // Default to descending
											}
										});

										// 3. Re-render table
										tableBody.innerHTML = ''; // Clear the table
										if (filteredRows.length > 0) {
											filteredRows.forEach(row => {
												tableBody.appendChild(row);
											});
										} else {
											tableBody.innerHTML = '<tr><td colspan="7" class="no-data">No submissions match your filters.</td></tr>';
										}
									}

									const selectAllCheckbox = document.getElementById('select-all-checkbox');
									const rowCheckboxes = document.querySelectorAll('.row-checkbox');
									const bulkActionsBar = document.getElementById('bulk-actions-bar');
									const selectedCountSpan = document.getElementById('selected-count');
									const bulkUpdateBtn = document.getElementById('bulk-update-btn');

									if (selectAllCheckbox) {
										selectAllCheckbox.addEventListener('change', function () {
											rowCheckboxes.forEach(checkbox => {
												checkbox.checked = this.checked;
											});
											updateBulkActionsUI();
										});
									}

									rowCheckboxes.forEach(checkbox => {
										checkbox.addEventListener('change', updateBulkActionsUI);
									});

									function updateBulkActionsUI() {
										const selectedCheckboxes = document.querySelectorAll('.row-checkbox:checked');
										const selectedCount = selectedCheckboxes.length;

										if (selectedCount > 0) {
											bulkActionsBar.style.display = 'flex';
											selectedCountSpan.textContent = selectedCount;
										} else {
											bulkActionsBar.style.display = 'none';
										}

										if (selectedCount === 0) {
											selectAllCheckbox.checked = false;
											selectAllCheckbox.indeterminate = false;
										} else if (selectedCount === rowCheckboxes.length) {
											selectAllCheckbox.checked = true;
											selectAllCheckbox.indeterminate = false;
										} else {
											selectAllCheckbox.checked = false;
											selectAllCheckbox.indeterminate = true;
										}
									}

									if (bulkUpdateBtn) {
										bulkUpdateBtn.addEventListener('click', function () {
											const selectedCheckboxes = document.querySelectorAll('.row-checkbox:checked');
											const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.id);
											const newStatus = document.getElementById('bulk-status-update').value;

											if (selectedIds.length === 0) {
												alert('Please select at least one submission to update.');
												return;
											}

											console.log('--- Bulk Update Action ---');
											console.log('Selected IDs:', selectedIds);
											console.log('New Status:', newStatus);
											console.log('Form Token:', document.querySelector('input[name="__RequestVerificationToken"]').value);

											alert('Bulk Update UI is functional.\n\nA server-side endpoint (Controller Action) is required to process this request.\n\nCheck the browser console (F12) to see the data that would be sent.');
										});
									}

								});






			// ===== CRITICAL FIXES (Added for filter collapse, table positioning, and bulk actions) =====

			// ===== FILTER COLLAPSE/EXPAND FIX =====
			function setupFilterToggleFix() {
				const filterToggle = document.getElementById('filterToggle');
				const filterSection = document.getElementById('filterSection');

				if (filterToggle && filterSection) {
					filterToggle.addEventListener('click', function(e) {
						e.preventDefault();
						filterSection.classList.toggle('collapsed');
					});
				}
			}

			// ===== DEPARTMENT TABS POPULATION FIX =====
			function populateDepartmentTabsFix() {
				const departmentTabs = document.getElementById('departmentTabs');
				if (departmentTabs && !departmentTabs.innerHTML.includes('data-dept')) {
					const departments = ['All', 'Computer Science', 'Engineering', 'Biology', 'Chemistry', 'Physics'];
					departmentTabs.innerHTML = departments.map((dept, idx) =>
						`<span class="filter-tab ${idx === 0 ? 'active' : ''}" data-dept="${dept}" onclick="filterByDept(this)">${dept}</span>`
					).join('');
				}
			}

			// ===== SERVICE TABS POPULATION FIX =====
			function populateServiceTabsFix() {
				const serviceTabs = document.getElementById('serviceTabs');
				if (serviceTabs && !serviceTabs.innerHTML.includes('data-service')) {
					const services = ['All', 'Originality Check', 'Formatting Review', 'Editing Service', 'Peer Review'];
					serviceTabs.innerHTML = services.map((svc, idx) =>
						`<span class="filter-tab ${idx === 0 ? 'active' : ''}" data-service="${svc}" onclick="filterByService(this)">${svc}</span>`
					).join('');
				}
			}

			// ===== FILTER BY DEPARTMENT FIX =====
			function filterByDept(element) {
				if (!element) return;
				document.querySelectorAll('#departmentTabs .filter-tab').forEach(t => t.classList.remove('active'));
				element.classList.add('active');
				// Your existing filter logic will be called
				if (typeof applyFilters === 'function') {
					applyFilters();
				}
			}

			// ===== FILTER BY SERVICE FIX =====
			function filterByService(element) {
				if (!element) return;
				document.querySelectorAll('#serviceTabs .filter-tab').forEach(t => t.classList.remove('active'));
				element.classList.add('active');
				// Your existing filter logic will be called
				if (typeof applyFilters === 'function') {
					applyFilters();
				}
			}

			// ===== BULK ACTIONS BAR FIX =====
			function updateBulkActionsUI() {
				const bulkActionsBar = document.getElementById('bulkActionsBar');
				const selectedCheckboxes = document.querySelectorAll('.submission-checkbox:checked');

				if (bulkActionsBar) {
					if (selectedCheckboxes.length > 0) {
						bulkActionsBar.style.display = 'flex';
						document.getElementById('selectedSubmissionsCount').textContent = selectedCheckboxes.length;
					} else {
						bulkActionsBar.style.display = 'none';
					}
				}
			}

			// ===== TOGGLE CHECKBOX FIX =====
			function toggleCheckboxFix(checkbox) {
				checkbox.addEventListener('change', updateBulkActionsUI);
				// Add row highlight
				const row = checkbox.closest('tr');
				if (row) {
					if (checkbox.checked) {
						row.style.backgroundColor = 'rgba(59, 130, 246, 0.05)';
					} else {
						row.style.backgroundColor = '';
					}
				}
				updateBulkActionsUI();
			}

			// ===== SELECT ALL FIX =====
			function setupSelectAll() {
				const selectAllCheckbox = document.getElementById('selectAllCheckbox');
				if (selectAllCheckbox) {
					selectAllCheckbox.addEventListener('change', function() {
						document.querySelectorAll('.submission-checkbox').forEach(cb => {
							cb.checked = this.checked;
							toggleCheckboxFix(cb);
						});
						updateBulkActionsUI();
					});
				}
			}

			// ===== INITIALIZE ALL FIXES =====
			function initializeFixesFix() {
				setupFilterToggleFix();
				populateDepartmentTabsFix();
				populateServiceTabsFix();
				setupSelectAll();

				// Setup checkbox listeners
				document.querySelectorAll('.submission-checkbox').forEach(cb => {
					toggleCheckboxFix(cb);
				});
			}

			// Run on page load
			document.addEventListener('DOMContentLoaded', function() {
				setTimeout(initializeFixesFix, 100);
			});

			// Also run immediately if DOM is already loaded
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeFixesFix);
			} else {
				initializeFixesFix();
			}

					   document.addEventListener('DOMContentLoaded', function() {
				// Collapse/expand handler
				const filterSection = document.getElementById('filterSection');
				const filterToggle = document.getElementById('filterToggle');
				if (filterSection && filterToggle) {
					filterToggle.addEventListener('click', function(e) {
						e.preventDefault();
						filterSection.classList.toggle('collapsed');
					});
				}

				// Reset Filters handler
				const resetBtn = document.getElementById('clearFiltersBtn');
				if (resetBtn) {
					resetBtn.addEventListener('click', function() {
						// Reset status
						let status = document.getElementById('statusFilter');
						if (status) status.value = 'all';

						// Reset sort
						let sort = document.getElementById('dateSortFilter');
						if (sort) sort.value = 'desc';

						// Reset date filters
						let df = document.getElementById('dateFromFilter');
						let dt = document.getElementById('dateToFilter');
						if (df) df.value = '';
						if (dt) dt.value = '';

						// Reset department tabs
						let dTabs = document.querySelectorAll('#departmentTabs .filter-tab');
						let dDefault = document.querySelector('#departmentTabs .filter-tab[data-dept=\"All\"]');
						if (dTabs && dDefault) {
							dTabs.forEach(t => t.classList.remove('active'));
							dDefault.classList.add('active');
						}

						// Reset service tabs
						let sTabs = document.querySelectorAll('#serviceTabs .filter-tab');
						let sDefault = document.querySelector('#serviceTabs .filter-tab[data-service=\"All\"]');
						if (sTabs && sDefault) {
							sTabs.forEach(t => t.classList.remove('active'));
							sDefault.classList.add('active');
						}

						// Call your filtering logic!
						if (typeof applyFilters === 'function') applyFilters();
					});
				}
			});






		</script>


		<!-- ===== BULK SELECT FUNCTIONALITY ===== -->
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				// --- Bulk Action Elements ---
				const selectAll = document.getElementById('selectAllCheckbox');
				const bulkBar = document.getElementById('bulkActionsBar');
				const bulkApplyBtn = document.getElementById('bulkApplyBtn');
				const bulkClearBtn = document.getElementById('bulkClearBtn');
				const bulkStatusSelect = document.getElementById('bulkStatusSelect');

				// --- Filter Elements ---
				const applyFilterBtn = document.getElementById('applyFilterBtn');
				const resetFilterBtn = document.getElementById('resetFilterBtn');
				const searchInput = document.getElementById('searchInput');
				const statusFilter = document.getElementById('statusFilter');
				const startDateInput = document.getElementById('startDate');
				const endDateInput = document.getElementById('endDate');

				// FIX 1: 'tableBody' must be defined before it can be used below.
				// Assumes your table's body has a <tbody> tag.
				const tableBody = document.querySelector('tbody');

				// --- Bulk Action Logic ---
				function updateBulkBar() {
					// Find all checkboxes *within the table body*
					const boxes = tableBody.querySelectorAll('.bulk-checkbox');
					const checked = Array.from(boxes).filter(cb => cb.checked);
					document.getElementById('selectedCount').textContent = checked.length;

					if (bulkBar) {
						bulkBar.style.display = checked.length > 0 ? 'flex' : 'none';
					}

					if (bulkApplyBtn) {
						bulkApplyBtn.disabled = checked.length === 0 || !bulkStatusSelect.value;
					}

					// Also update the "Select All" checkbox state
					if (selectAll && boxes.length > 0) {
						selectAll.checked = checked.length === boxes.length;
					} else if (selectAll) {
						selectAll.checked = false;
					}
				}

				if (selectAll) {
					selectAll.addEventListener('change', function() {
						tableBody.querySelectorAll('.bulk-checkbox').forEach(cb => {
							cb.checked = this.checked;
						});
						updateBulkBar();
					});
				}

				// Use event delegation on the table body for row checkboxes.
				// This is more efficient and works for rows added dynamically.
				if (tableBody) {
					tableBody.addEventListener('change', function(e) {
						if (e.target.classList.contains('bulk-checkbox')) {
							updateBulkBar();
						}
					});
				}

				if (bulkStatusSelect) {
					bulkStatusSelect.addEventListener('change', updateBulkBar);
				}

				if (bulkClearBtn) {
					bulkClearBtn.addEventListener('click', function() {
						if (selectAll) selectAll.checked = false;
						tableBody.querySelectorAll('.bulk-checkbox').forEach(cb => cb.checked = false);
						if (bulkStatusSelect) bulkStatusSelect.value = '';
						updateBulkBar();
					});
				}

				if (bulkApplyBtn) {
					bulkApplyBtn.addEventListener('click', function() {
						const status = bulkStatusSelect.value;
						const ids = Array.from(tableBody.querySelectorAll('.bulk-checkbox:checked')).map(cb => cb.dataset.id);

						if (!status || ids.length === 0) {
							alert('Please select items and a status');
							return;
						}

						if (confirm('Update ' + ids.length + ' item(s) to "' + status + '"?')) {
							const token = document.querySelector('input[name="__RequestVerificationToken"]').value;

							fetch('/Admin/BulkUpdateStatus', {
									method: 'POST',
									headers: {
										'Content-Type': 'application/x-www-form-urlencoded',
									},
									// Body is URL-encoded, including the anti-forgery token
									body: 'ids=' + encodeURIComponent(ids.join(',')) +
										'&status=' + encodeURIComponent(status) +
										'&__RequestVerificationToken=' + encodeURIComponent(token)
								})
								.then(response => {
									if (!response.ok) {
										throw new Error('Network response was not ok');
									}
									return response.json();
								})
								.then(data => {
									if (data.success) {
										// Show success message, then reload the page when "OK" is clicked
										showCustomAlert(data.message || `Successfully updated ${ids.length} item(s).`, () => {
											location.reload();
										});
									} else {
										// FIX 3: Removed the stray 'D' character
										showCustomAlert('Error: ' + (data.message || 'An unknown error occurred.'));
									}
								})
								.catch(error => {
									// Show network or other critical errors
									console.error('Error:', error);
									showCustomAlert('A connection error occurred. Please try again.');
								});
						}
					});
				}

				// --- Filter Logic Integration ---

				// Ensure tableBody exists before getting rows
				const rows = tableBody ? Array.from(tableBody.querySelectorAll('tr')) : [];

				function filterTable() {
					// When filtering, deselect all checkboxes
					// FIX 2: Changed 'clearSelectionsBtn' to 'bulkClearBtn'
					if (bulkClearBtn) bulkClearBtn.click();

					const searchTerm = searchInput.value.toLowerCase();
					const statusTerm = statusFilter.value;
					const startDate = startDateInput.value;
					const endDate = endDateInput.value;
					let hasVisibleRows = false;

					rows.forEach(row => {
						// Check if it's a data row (not a "no data" row)
						if (row.cells.length <= 1) {
							row.style.display = 'none'; // Hide "no data" row by default
							return;
						}

						const rowData = row.textContent.toLowerCase();
						const rowStatus = row.dataset.status;
						const rowDate = row.dataset.date;

						let matchesSearch = !searchTerm || rowData.includes(searchTerm);
						let matchesStatus = !statusTerm || rowStatus === statusTerm;

						let matchesDate = true;
						if (startDate && rowDate < startDate) {
							matchesDate = false;
						}
						if (endDate && rowDate > endDate) {
							matchesDate = false;
						}

						if (matchesSearch && matchesStatus && matchesDate) {
							row.style.display = ''; // Show row
							hasVisibleRows = true;
						} else {
							row.style.display = 'none'; // Hide row
						}
					});

					// Show "no data" row if no other rows are visible
					const noDataRow = rows.find(r => r.cells.length <= 1);
					if (noDataRow && !hasVisibleRows) {
						noDataRow.style.display = '';
					}

					// After filtering, update the "Select All" checkbox state
					updateBulkBar();
				}

				if (applyFilterBtn) {
					applyFilterBtn.addEventListener('click', filterTable);
				}

				if (resetFilterBtn) {
					resetFilterBtn.addEventListener('click', () => {
						searchInput.value = '';
						statusFilter.value = '';
						startDateInput.value = '';
						endDateInput.value = '';
						filterTable(); // Re-apply filters (which will show all)
					});
				}

				// Initial call to set up the bulk bar (in case of reloads)
				updateBulkBar();
			});
		</script>

</body>
</html>